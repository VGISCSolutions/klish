# Klish версия 3

## Обзор

Программа klish предназначенa для организации интерфейса командной строки,
в котором оператору доступен только строго определенный набор команд. Это
отличает klish от стандартных shell интерпретаторов, где оператор может
использовать любые команды, существующие в системе и возможность их выполнения
зависит только от прав доступа. Набор доступных в klish команд определяется на
этапе конфигурирования и может быть задан, в общем случае, различными способами,
основным из которых являются XML файлы конфигурирования. Команды в klish не
являются системными командами, а полностью определены в файлах конфигурации,
со всеми возможными параметрами, синтаксисом и действиями, которые они
выполняют.

Основным применением klish являются встроенные системы, где оператору доступны
только определенные, специфические для конкретного устройства, команды, а не
произвольный набор команд, как в системах общего назначения. В таких встроенных
системах klish может подменить собой shell интерпретатор, недоступный для
оператора.

Примером встроенных систем может служить управляемое сетевое оборудование.
Исторически в этом сегменте сложилось два основных подхода к организации
интерфейса командной строки. Условно их можно назвать подход "Cisco" и подход
"Juniper". И Cisco и Juniper имеют два режима работы - командный режим и
режим конфигурирования. В командном режиме введенные команды немедленно
исполняются, но не влияют на конфигурацию системы. Это команды просмотра
состояния, команды управления устройством, но не изменения его конфигурации.
В режиме конфигурирования
идет настройка оборудования и сервисов. В Cisco команды конфигурирования также
исполняются немедленно, меняя конфигурацию системы. В Juniper конфигурацию
можно условно представить себе, как текстовый файл, изменения в котором
производятся с помощью стандартных команд редактирования. При редактировании
изменения не применяются в системе. И только по специальной команде весь
накопленный комплекс изменений применяется разом, чем обеспечивается
согласованность изменений. При Cisco подходе похожее поведение также можно
эмулировать, проектируя команды определенным образом, но для Cisco это менее
естественный способ.

Какой из подходов лучше и проще в конкретном случае - определяется задачей.
Klish в первую очередь расчитан на подход Cisco, т.е. на немедленно выполняемые
команды. Однако проект имеет систему плугинов, что позволяет расширять его
возможности. Так плугин klish-plugin-sysrepo, реализованный отдельным проектом,
работая на основе хранилища sysrepo, позволяет организовать Juniper подход.


## Основные сведения

Основа проекта klish - библиотека libklish. На ее основе построены клиент klish
и сервер klishd. Основную работу выполняет сервер klishd. Он загружает
конфигурацию команд и ожидает запросов от клиентов. Взаимодействие между
клиентами и сервером происходит по UNIX-сокетам с использованием специально
разработанного для этой цели протокола KTP (Klish Transfer Protocol). Задача
клиента - передача ввода от оператора на сервер и получение от него
результата для показа оператору. Клиент не знает, какие команды существуют,
как их выполнять. Все это делает серверная сторона. Так как клиент имеет
относительно простой код, не трудно реализовать альтернативные программы -
клиенты, например графический клиент или клиент для автоматизированного
управления. Сейчас написан только текстовый клиент klish. Когда клиент
соединяется с сервером, порождается отдельный процесс для обслуживания
конкретного клиента. При завершении сессии, процесс также завершается. Таким
образом типичное применение klish - это заранее запущенный в системе сервер
klishd и клиенты, подключающиеся к нему по мере надобности.

Klish имеет два типа плугинов. Плугины для загрузки конфигурации команд
(директория dbs/ в дереве исходных кодов) и плугины, реализующие действия для
команд (директория plugins/ в дереве исходных кодов).

Для настройки параметров сервера используется конфигурационный файл
'/etc/klish/klishd.conf'. Альтернативный конфигурационный файл можно указать при
запуске сервера klishd.

Для настройки параметров клиента используется конфигурационный файл
'/etc/klish/klish.conf'. Альтернативный конфигурационный файл можно указать при
запуске клиента klish.


## Загрузка конфигурации команд

В составе klish существуют следующие плугины dbs (DataBases) для загрузки
конфигурации команд (схемы):

* expat - Использует библиотеку expat для загрузки конфигурации из XML.
* libxml2 - Использует библиотеку libxml2 для загрузки конфигурации из XML.
* roxml - Использует библиотеку roxml для загрузки конфигурации из XML.
* ischeme - Использует встроенную в C-код конфигурацию (Internal Scheme).

Существует внутреннее представление схемы, совпадающее с ischeme.
Остальные плугины переводят внешние представление в ischeme, а klish
обрабатывает ischeme внутренними механизмами.

Установленные плугины dbs находятся в '/usr/lib/klish/dbs' (если конфигурировать
сборку с --prefix=/usr). Их имена 'kdb-<имя>.so', например
'/usr/lib/klish/dbs/kdb-libxml2.so'.

## Плугины исполняемых функций

Каждая команда klish выполняет какое-либо действие или несколько действий сразу.
Эти действия надо как-то описывать. Если смотреть внутрь реализации, то klish
может запускать только исполняемый откомпилированный код из плугина. Плугины
содержат так называемые символы (symbol, sym), которые, по-сути, представляют
собой функции с единым зафиксированным API. На эти символы могут ссылаться
команды klish. В свою очередь символ может выполнять сложный код, например
запускать интерпретатор shell со скриптом, определяемым при описании команды
klish в конфигурационном файле. Или же другой символ может исполнять Lua скрипт.

Klish умеет получать символы только из плугинов. Стандартные символы реализованы
в плугинах включенных в состав проекта klish. В состав klish входят следующие
плугины:

* klish - Базовый плугин. Навигация, типы данных (для параметров),
вспомогательные функции.
* lua - Исполнение скриптов Lua. Механизм встроен в плугин и не использует
внешнюю программу для интерпретации.
* script - Исполнение скриптов. Учитывает шебанг (shebang) для определения
какой интерпретатор использовать. Таким образом могут выполняться не только
shell скрипты, но и скрипты на других интерпретируемых языках. По умолчанию
используется интерпретатор shell.